//includes
#include <header/header.fxh>
#include <Shaders/base_tex.fxh>
#include <includes/uma-common.hlsl>
#include <Shaders/outline_shader.fxsub>
//

//base structure
struct vs_in
{
    float4 pos          : POSITION;
    float3 normal       : NORMAL;
    float2 uv            : TEXCOORD0;
    float4 vertexcolor   : TEXCOORD3; //umaviewer uses texcoord3 
};


struct vs_out
{
    float4 pos          : POSITION;
    float2 uv           : TEXCOORD0;
    float4 vertex       : TEXCOORD1;
    float3 normal       : TEXCOORD2;
    float3 view         : TEXCOORD3;
};

vs_out vs_model ( vs_in i)
{
    vs_out o = (vs_out)0; //you're not mentally sane if you write this as INPUT/OUTPUT
    o.pos = mul(i.pos, mmd_wvp);
    o.uv = i.uv;
    o.vertex = i.vertexcolor;
	o.normal = mul((float3x3) mmd_world, i.normal);
    o.view = mmd_cameraPosition - mul(i.pos.xyz, (float3x3)mmd_world);
    return o;
}

float4 ps_model(vs_out i, float vface : VFACE) : COLOR0
{

    UmaParams();
    float2 uv = i.uv;
    float4 vertexcol = i.vertex;
    float3 normal = normalize(i.normal);
    float3 view = normalize(i.view);
    float3 half_vec = normalize(view + -light_d);
    float4 color = egColor;
    float4 diffuse = tex2D(diffuseSampler, uv);
    float4 option = tex2D(OptionSampler, uv);
    float4 triple = tex2D(TripleSampler, uv);
    #ifndef AlphaBlend
        if(triple.z < _Cutoff) discard; //literally all there is to alpha
    #else 
        color.w = triple.z;
    #endif
    color.rgb *= diffuse.rgb;

    float2 option_lerp = lerp(0.5, option.yz, _UseOptionMaskMap);

    float ndotl = dot(normal, -light_d) * 0.5 + 0.5;

    float shadow = UmaShadow(ndotl, triple.x);
    float3 shadowcol = tex2D(ToonSampler, uv) * egColor * _GlobalToon.xyz;

    float vertpow = whateverthisis(vertexcol.w, ndotl, _VertexColorToonPower);

    color.xyz = ToonShift(color.xyz, ToonBrightColor, vertpow);
    shadowcol = ToonShift(shadowcol.xyz, ToonDarkColor, vertpow);

    float3 rimspecenv = UmaRimSpec(normal, view, option_lerp.y, triple.y);

    float rimmask = max(ndotl, 0.0);
    float rimshadow = rimmask + _RimShadow + _RimShadowRate;
    float rimshadow2 = rimmask  + _RimShadowRate2; // okay
    //env
    float3 envuv = mul(normal, (float3x3)mmd_view);
    envuv.xy = envuv.xy * float2(0.5, -0.5) + 0.5;
    float3 env = tex2D(EnvSampler, envuv.xy);
    env = (color * env);



    color.xyz = lerp(color.xyz, shadowcol, shadow);
    color.xyz += (rimspecenv.x * lerp(_SpecularColor, RimColor.xyz, _RimSpecRate) * rimshadow);
    color.xyz += (rimspecenv.y * lerp(_SpecularColor, RimColor2.xyz, _RimSpecRate2) * rimshadow2);
    color.xyz = lerp(color, env * EnvBias, option.y * EnvRate);
    color.xyz += (rimspecenv.z * (_SpecularColor * egColor));
    
    #ifdef _EmissiveTex
        float3 emission = tex2D(EmissionSampler, uv).xyz * _EmissiveColor.xyz;
        color.xyz += emission;
    #endif

    #ifdef _ReflectionMap // fuck pc shaders man
        float4 refl = tex2D(ReflectionSampler, envuv); // reusing enuv for now, also float4 because i think they intend on adding more, fail safe.
        refl.xy *= ReflectionBias;

        float3 reflcol = pow(max(ReflectionAddColor * shadowcol, (float3)0.0f), ReflectionPowVal); // sure

        float3 colormul = ReflectionMulColor * refl.x + color;
        float3 coloradd = lerp(1, reflcol, refl.y);

        color.xyz = lerp(color.xyz, colormul * coloradd, ReflectionRate * option.x);
    #endif 

    if(mmd_ray)
    {
        AdjustForRayMMD(color.xyz);
    }
    Generate_Saturation(color.xyz);
    Generate_Silhouette(color.xyz);
    
    return color;
}

technique model_SS_tech <string MMDPASS = "object_ss"; >
{
    pass main
    {
        StencilRef = _StencilMask;
        StencilFunc = NOTEQUAL;
        StencilPass = KEEP;
        VertexShader = compile vs_3_0 vs_model();
        PixelShader = compile ps_3_0 ps_model();
    }
    #ifndef AlphaBlend
        pass edge
        {
            StencilRef = _StencilMask;
            StencilFunc = NOTEQUAL;
            StencilPass = KEEP;
            cullmode = cw;
            VertexShader = compile vs_3_0 vs_edge();
            PixelShader = compile ps_3_0 ps_edge();
        }
    #endif
}

technique model_tech <string MMDPASS = "object"; >
{
    pass main
    {
        StencilRef = _StencilMask;
        StencilFunc = NOTEQUAL;
        StencilPass = KEEP;
        VertexShader = compile vs_3_0 vs_model();
        PixelShader = compile ps_3_0 ps_model();
    }
    #ifndef AlphaBlend
        pass edge
        {
            StencilRef = _StencilMask;
            StencilFunc = NOTEQUAL;
            StencilPass = KEEP;
            cullmode = cw;
            VertexShader = compile vs_3_0 vs_edge();
            PixelShader = compile ps_3_0 ps_edge();
        }
    #endif
}


technique edge <string MMDPASS = "edge";>{} //FUCK your pmx settings
technique shadow <string MMDPASS = "shadow";>{}